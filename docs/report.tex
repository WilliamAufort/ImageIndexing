\input{macros.tex}

\title{A binary shape indexing/retrieval system}
\author{
    William \textsc{Aufort}\\
    Marc \textsc{Chevalier}
}
\date{\today}

\begin{document}
\maketitle

\section*{Introduction}

\subsection*{General introduction}

The objective of this project is to design a binary shape indexing system. Given a database of binary shapes (PGM files) associated to different classes, and a binary image, the goal is to find the class whch correspond the most to the image. In this document, we present and explain our main ideas to solve the problem and our implementation choices.

\subsection*{The database used}

% TODO Quelques mots sur la base de données, le type d'images (noir & blanc, type d'objets --> difficulté, ...)

\section{Granulometric analysis applied to shape indexing}

\subsection{Basic ideas}

When we are watching images, to associate them to concepts, we use our knowledge of these concepts. For example, an apple is a quite circular object with sometimes a stalk and leaves, a camel is a mammal with one or two humps, etc. Basically, for organic objects, we use a kind of segmentation caracterisation to identify the concepts: we recover it by identify its different parts.

A famous tool used in volumetric analysis to determine segmentation is the \textbf{granulometric function}. Indeed, it plays an important role for shape description, what we want exactly to do.

\begin{defi}[Granulometric function]
Let $\mathcal{X}$ be a binary shape in $\Ztwo$. We denoted by $B(c,r)$ the euclidean ball with center $c \in \Ztwo$ and radius $r \in \RR$. We define the granulometric function $g_{\mathcal{X}}$ on $\mathcal{X}$ by :

$$ g_{\mathcal{X}}(x) = \operatorname{max} \left\{ r | \exists c \in \mathcal{X}, x \in B(c,r) \wedge B(c,r) \subseteq \mathcal{X} \right\} $$ 
\end{defi}

In other words, we are looking for the radius of the greatest ball included in the shape $\mathcal{X}$ which contains our point $x$.

If we plot the granulometry function on a 2D shape in the database, we can observe that the different values of the granulometric function correspond to the different "parts" of the object. An example is given on figure \ref{apple-granulo}.

\begin{figure}[!ht]
    \centering
    \subfloat{
        \label{apple-granulo:1}   
        \includegraphics[height=175pt]{images/apple-1}
    }
    \qquad\qquad\qquad
    \subfloat{
        \label{apple-granulo:2}
        \includegraphics[height=175pt]{images/apple-1-granulo}
    }
    \caption{The granulometric function illustrated in this apple image. We can easily distinguish the different natural parts of the apple using the granulometric function.}
    \label{apple-granulo}
\end{figure}

We can use the granulometric function to compare two images. To do this, we can see the granulometric function as a distribution of the radius of the maximal balls over the object $\mathcal{X}$, which can be describes for examples with histograms like those we use in statistics. Compare two images remains to compare two histograms, so we have to define a distance between histograms.

\subsection{Advantages}

\subsubsection{Invariant by translation, rotation and symmetry}

The invariance with respect to translation, rotation and symmetry is an important property. But we have to be a little bit more precise:

\begin{theo}[Invariance by translation]
	Let $\mathcal{X}$ be a binary shape in $\Ztwo$. Let $\vec{t} \in \Ztwo$ be a vector of translation, and let $\mathcal{X}_{t} = \left\{ x + \vec{t}, x \in \mathcal{X} \right\}$. Then :
	
	$$ \forall x \in \mathcal{X}_{t}, g_{\mathcal{X}_{t}}(x) = g_{\mathcal{X}}(x-\vec{t}) $$
\end{theo}

In other words, there is a trivial isomorphism between the two images $\mathcal{X}$ and  $\mathcal{X}_t$ seen as unions of balls. With this remark, the proof of the theorem is completely trivial.

But the same result for rotations is not completely trivial. If we take a rotation of any angle, one can imagine that the pixels of the image, after the rotation, don't match exactly with points in $\Ztwo$, because of the trigonometric functions implied during the process. The same behaviour occurs if we consider symmetries with respect to any line or center.

Nonetheless, intuitively if there exists some modifications in the granulometric function, they are not going to be very large in some sense.

% TODO : See if we can quantify the difference between the two.

\subsection{Disadvantages}

\subsubsection{Geometrical objects with perturbations}

Some of the classes are defined by the basic geometrical object they refers to. For example, the object presented in the figure \ref{device9-6}, as all the elements in the class \texttt{device9}, are very close to a ball, excepted that they are crossed by some perturbating element (in the figure it's a line). The problem on such images is that that king of noise perturbate a lot the output of the granulometric function, as we can see in the figure \ref{device9-6}.

\begin{figure}[!ht]
    \centering
    \subfloat{
        \label{device9-6:1}
        \includegraphics[height=175pt]{images/device9-6-object}
    }
    \qquad\qquad\qquad
    \subfloat{
        \label{device9-6:2}
        \includegraphics[height=175pt]{images/device9-6-granulo}
    }
    \caption{The granulometric function is very perturbated on this geometrical object crossed by a curve.}
	\label{device9-6}
\end{figure}

\subsubsection{Loss of spatial information}

% TODO dire quelque chose ici, voir une ouverture sur d'autres methodes (notamment les papiers que l'on a regardé)


\subsection{Implementation}

The general idea of the algorithms that computes the granulometric function is to get a quite good set of candidate balls. A ball included in the image is a candidate ball if it must have a contribution on the granulometric function of a point of the image. Indeed, most of the complexity of the algorithm leads on the iterator over those balls in order to compute the maximal radius for each point. 

We present two algorithms. The first one is quite naive and have been implemented first. It uses only the distance transformation (DT). The second one, clorer to the medial axis concept, is an optimization where we drastically reduce the number of candidate balls to scan.

\subsubsection{Naive algorithm : Distance Transformation}

We recall the definition of the Distance Transformation saw during the class :

\begin{defi}[Distance transformation]
Let $\mathcal{X}$ be a binary shape in $\Ztwo$. If $p$ is a point of $\mathcal{X}$, we called the Distance transformation at $p$, denoted by $DT(p)$, the smallest distance to the border of the image :
$$ DT(p) = \underset{q \in \widetilde{\mathcal{X}}}{min} \quad d(p,q) $$
\end{defi}

$DT(p)$ represents the maximum radius of a ball containing $p$, included in $\mathcal{X}$. We are interested in it because of this trivial result :

\begin{theo}[]
	For all $p \in \mathcal{X}$, for all $r$ such that $B(p,r) \subset \mathcal{X}$, we have :
		$$ B(p,r) \subset B(p,DT(p))$$
\end{theo}

With this result, we can restrict the number of balls to scan to $\cplx{\left| \mathcal{X} \right|}$. Indeed, we can consider only the balls $\set{B(p,DT(p)), p \in \mathcal{X}}$, because of the other balls are included in some of those ones.

Once we have computed the Distance Transformation, the algorithm to compute the granulometric function works as follows:

\IncMargin{1em}
\begin{algorithm}
\ForEach{point $p \in \mathcal{X}$}{
    Create a ball centered at $p$ with radius $DT(p)$\;
    \ForEach{point $q$ in this ball}{
        \If{$g(y) \leq DT(p)$}{
			$g(y) \leftarrow DT(p)$\;
		}
	}
}
\caption{Naive algorithm to compute the granulometric function $g$}
\label{algo-naive}
\end{algorithm}

\section{How to deal with noise: choices and implementation}

An important aspect of the project is to deal with image which can be potentially noised.

We were interested in deleting specular noise. Our choice is to implement a binomial filter saw during the course. This filter, used essentially for smoothing grayscale images, erases the potential specular noise on the image. If the image is not noisy, the experiment show that the initial image is not modified. The initial filter (i.e. for a grayscale image) is :

\setcounter{MaxMatrixCols}{3}
\[ F = \quad \frac{1}{16} \begin{pmatrix}
1 & 2 & 1 \\
2 & 4 & 2 \\
1 & 2 & 1
\end{pmatrix}\]

In the grayscale output image, we only keep the pixels with intensity greater than $8 \times 255$, where $8$ represents half of the sum of the weights in the filter ($16$ here) and $255$ the intensity for the white part of the image (i.e. the final object we keep). For more simplicity, we don't keep the $255$ factor, since the only possible intensity values in the input image are $0$ and $255$.

We give the simplier implementation of the filter in the file \texttt{deleteNoise.cpp}. One could improve it, for example using the fact that this filter is separable.

\end{document}
