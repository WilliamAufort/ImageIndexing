\input{macros.tex}

\title{A binary shape indexing/retrieval system}
\author{
    William \textsc{Aufort}\\
    Marc \textsc{Chevalier}
}
\date{\today}

\begin{document}
\maketitle

\section*{Introduction}

The objective of this project is to design a binary shape indexing system. Given a database of binary shapes (PGM files) associated to different classes, and a binary image, the goal is to find the class whch correspond the most to the image. In this document, we present and explain our main ideas to solve the problem and our implementation choices.

\section{Granulometric analysis applied to shape indexing}

\subsection{Basic ideas}

When we are watching images, to associate them to concepts, we use our knowledge of these concepts. For example, an apple is a quite circular object with sometimes a stalk and leaves, a camel is a mammal with one or two humps, etc. Basically, for organic objects, we use a kind of segmentation caracterisation to identify the concepts: we recover it by identify its different parts.

A famous tool used in volumetric analysis to determine segmentation is the \textbf{granulometric function}. Indeed, it plays an important role for shape description, what we want exactly to do.

Let $\mathcal{X}$ be a binary shape in $\Ztwo$. We denoted by $B(c,r)$ the euclidean ball with center $c \in \Ztwo$ and radius $r \in \RR$. We define the granulometric function $g$ on $\mathcal{X}$ by :

$$ g(x) = \operatorname{max} \left\{ r | \exists c \in \mathcal{X}, x \in B(c,r) \wedge B(c,r) \subseteq \mathcal{X} \right\} $$ 

In other words, we are looking for the radius of the greatest ball included in the shape $\mathcal{X}$ which contains our point $x$.

If we plot the granulometry function on a 2D shape in the database, we can observe that the different values of the granulometric function correspond to the different "parts" of the object. An example is given on figure \ref{apple-granulo}.

% Note : use pnmtopng to convert.

\begin{figure}[!ht]
    \centering
    \subfloat{
        \label{apple-granulo:1}   
        \includegraphics[height=175pt]{images/apple-1}
    }
    \qquad\qquad\qquad
    \subfloat{
        \label{apple-granulo:2}
        \includegraphics[height=175pt]{images/apple-1-granulo}
    }
    \caption{The granulometric function illustrated in this apple image. We can easily distinguish the different natural parts of the apple using the granulometric function.}
    \label{apple-granulo}
\end{figure}

We can use the granulometric function to compare two images. To do this, we can see the granulometric function as a distribution of the radius of the maximal balls over the object $\mathcal{X}$, which can be describes for examples with histograms like those we use in statistics. Compare two images remains to compare two histograms, so we have to define a distance between histograms.

\subsection{Advantages}

\subsubsection{Invariant by translation}



\subsection{Disadvantages}

\subsubsection{Geometrical objects with perturbations}

Some of the classes are defined by the basic geometrical object they refers to. For example, the object presented in the figure \ref{device9-6}, as all the elements in the class \texttt{device9}, are very close to a ball, excepted that they are crossed by some perturbating element (in the figure it's a line). The problem on such images is that that king of noise perturbate a lot the output of the granulometric function, as we can see in the figure \ref{device9-6}.

\begin{figure}[!ht]
    \centering
    \subfloat{
        \label{device9-6:1}
        \includegraphics[height=175pt]{images/device9-6-object}
    }
    \qquad\qquad\qquad
    \subfloat{
        \label{device9-6:2}
        \includegraphics[height=175pt]{images/device9-6-granulo}
    }
    \caption{The granulometric function is very perturbated on this geometrical object crossed by a curve.}
	\label{device9-6}
\end{figure}

\subsection{Implementation}

\section{How to deal with noise: choices and implementation}

An important aspect of the project is to deal with image which can be potentially noised.

We were interested in deleting specular noise. Our choice is to implement a binomial filter saw during the course. This filter, used essentially for smoothing grayscale images, erases the potential specular noise on the image. If the image is not noisy, the experiment show that the initial image is not modified. The initial filter (i.e. for a grayscale image) is :

\setcounter{MaxMatrixCols}{3}
\[ F = \quad \frac{1}{16} \begin{pmatrix}
1 & 2 & 1 \\
2 & 4 & 2 \\
1 & 2 & 1
\end{pmatrix}\]

In the grayscale output image, we only keep the pixels with intensity greater than $8 \times 255$, where $8$ represents half of the sum of the weights in the filter ($16$ here) and $255$ the intensity for the white part of the image (i.e. the final object we keep). For more simplicity, we don't keep the $255$ factor, since the only possible intensity values in the input image are $0$ and $255$.

We give the simplier implementation of the filter in the file \texttt{deleteNoise.cpp}. One could improve it, for example using the fact that this filter is separable.

\end{document}
